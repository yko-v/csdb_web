#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Dec  4 15:56:20 2025

@author: ChatGPT + fedora
"""

import yaml
import os
import argparse
import sqlite3

FIELDS_PATH = os.path.join("..", 'schemas/fields.yaml')
TABLES_PATH = os.path.join("..", 'schemas/tables.yaml')
OUT_SQL = os.path.join("..", 'data/generate_db.sql')

def load_yaml(path):
    with open(path, "r", encoding="utf8") as f:
        return yaml.safe_load(f)

def render_column(field_entry, fields_def):
    """
    field_entry:
        - "fieldname"
        - { name: fieldname, constraints: ["PRIMARY KEY"] }
    fields_def: dict from fields.yaml
    """
    if isinstance(field_entry, str):
        name = field_entry
        extra_constraints = []
    else:
        name = field_entry["name"]
        extra_constraints = field_entry.get("constraints", [])

    # type from fields.yaml
    field_info = fields_def[name]
    field_type = field_info["type"]

    constraints = field_info.get("constraints", []) + extra_constraints

    sql = f'"{name}" {field_type}'

    # add constraints
    for c in constraints:
        sql += f" {c}"

    return sql.strip()


def generate_create_table(table_name, table_def, fields_def):
    fields = table_def["fields"]

    # Автоматический PRIMARY KEY, если нет PK среди constraints
    has_pk = any(
        isinstance(f, dict) and "PRIMARY KEY" in f.get("constraints", [])
        for f in fields
    )

    if not has_pk:
        # делаем первое поле PK
        first = fields[0]
        if isinstance(first, str):
            fields[0] = {"name": first, "constraints": ["PRIMARY KEY"]}
        else:
            first.setdefault("constraints", []).append("PRIMARY KEY")

    # Генерация колонок
    columns_sql = [
        render_column(f, fields_def)
        for f in fields
    ]

    fk_sql = []
    for fk in table_def.get("foreign_keys", []):
        col = fk["column"]
        ref = fk["references"]
        ref_table = ref["table"]
        ref_col = ref.get("column", col)
        on_update = fk.get("on_update")
        on_delete = fk.get("on_delete")

        line = f'FOREIGN KEY ("{col}") REFERENCES "{ref_table}"("{ref_col}")'
        if on_update: line += f' ON UPDATE {on_update}'
        if on_delete: line += f' ON DELETE {on_delete}'
        fk_sql.append(line)

    all_lines = columns_sql + fk_sql

    sql = f'CREATE TABLE IF NOT EXISTS "{table_name}" (\n'
    sql += ",\n".join("  " + line for line in all_lines) + "\n"
    sql += ");\n"
    return sql



def generate_index_sql(table_name, idx_def):
    name = idx_def.get("name")
    cols = idx_def.get("columns", [])
    unique = idx_def.get("unique", False)
    partial = idx_def.get("partial", None)
    uq = "UNIQUE " if unique else ""
    cols_sql = ", ".join(f'"{c}"' for c in cols)
    where = f" WHERE {partial}" if partial else ""
    return f'CREATE {uq}INDEX IF NOT EXISTS "{name}" ON "{table_name}" ({cols_sql}){where};\n'


def main(args):
    fields = load_yaml(FIELDS_PATH) or {}
    tables = load_yaml(TABLES_PATH) or {}

    sql_parts = []
    # create tables
    for tname, tdef in tables.items():
        sql = generate_create_table(tname, tdef, fields)
        sql_parts.append(sql)
    # indexes
    for tname, tdef in tables.items():
        for idx in tdef.get("indexes", []):
            sql_parts.append(generate_index_sql(tname, idx))

    full_sql = "\n".join(sql_parts)

    with open(OUT_SQL, "w", encoding="utf8") as f:
        f.write("-- generated by yaml_to_sql.py\n")
        f.write(full_sql)

    print(f"Generated {OUT_SQL}")

    if args.sqlite:
        dbfile = args.sqlite
        print(f"Applying SQL to SQLite DB: {dbfile}")
        conn = sqlite3.connect(dbfile)
        cur = conn.cursor()
        cur.executescript(full_sql)
        conn.commit()
        conn.close()
        print("Database created/updated.")


if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--sqlite", "-s", help="Apply schema to sqlite file", required=False)
    args = p.parse_args()
    main(args)
